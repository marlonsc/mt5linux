#!/usr/bin/env python3
# ruff: noqa: T201, TRY300
"""Auto-generate MT5 enums from the real MetaTrader5 library.

This script extracts all constants from the MT5 library and generates
Python IntEnum classes for type-safe usage in neptor and mt5linux.

REQUIRES: Docker test container running on port 38812
  (tests/fixtures/docker-compose.yaml)

NO FALLBACK - fails if Docker not available.

Usage:
    python scripts/codegen_enums.py [--output PATH] [--check]

Options:
    --output PATH   Output file path (default: mt5linux/constants.py)
    --check         Check if file needs commit (for CI/pytest)

This script is run automatically before pytest via conftest.py.
If --check fails, commit the updated constants.py to the repository.
"""

from __future__ import annotations

import argparse
import ast
import operator
import os
import re
import shutil
import socket
import subprocess
import sys
from collections import defaultdict
from pathlib import Path

import rpyc
from rpyc.core.service import VoidService

from mt5linux.config import Defaults

# Mapping of MT5 constant prefixes to enum class names
PREFIX_TO_CLASS: dict[str, str] = {
    "TIMEFRAME_": "TimeFrame",
    "ORDER_TYPE_": "OrderType",
    "TRADE_ACTION_": "TradeAction",
    "ORDER_STATE_": "OrderState",
    "ORDER_FILLING_": "OrderFilling",
    "ORDER_TIME_": "OrderTime",
    "ORDER_REASON_": "OrderReason",
    "DEAL_TYPE_": "DealType",
    "DEAL_ENTRY_": "DealEntry",
    "DEAL_REASON_": "DealReason",
    "POSITION_TYPE_": "PositionType",
    "POSITION_REASON_": "PositionReason",
    "ACCOUNT_TRADE_MODE_": "AccountTradeMode",
    "ACCOUNT_STOPOUT_MODE_": "AccountStopoutMode",
    "ACCOUNT_MARGIN_MODE_": "AccountMarginMode",
    "SYMBOL_CALC_MODE_": "SymbolCalcMode",
    "SYMBOL_CHART_MODE_": "SymbolChartMode",
    "SYMBOL_OPTION_MODE_": "SymbolOptionMode",
    "SYMBOL_OPTION_RIGHT_": "SymbolOptionRight",
    "SYMBOL_ORDERS_MODE_": "SymbolOrdersMode",
    "SYMBOL_SWAP_MODE_": "SymbolSwapMode",
    "SYMBOL_TRADE_EXECUTION_": "SymbolTradeExecution",
    "SYMBOL_TRADE_MODE_": "SymbolTradeMode",
    "BOOK_TYPE_": "BookType",
    "TRADE_RETCODE_": "TradeRetcode",
    "COPY_TICKS_": "CopyTicksFlag",
    "TICK_FLAG_": "TickFlag",
    "DAY_OF_WEEK_": "DayOfWeek",
}


def is_rpyc_available(
    host: str = "localhost",
    port: int = Defaults.PORT_DOCKER_MAPPED,
) -> bool:
    """Check if rpyc server is available on test container port."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except (OSError, TimeoutError):
        return False


def extract_from_rpyc(
    host: str = "localhost",
    port: int = Defaults.PORT_DOCKER_MAPPED,
) -> dict[str, int]:
    """Extract constants from MT5 via rpyc 6.x native API."""
    # rpyc 6.x native API - connect to SlaveService
    conn = rpyc.connect(host, port, service=VoidService)
    mt5 = conn.root.getmodule("MetaTrader5")

    constants: dict[str, int] = {}
    all_names = dir(mt5)

    for name in all_names:
        # Only process uppercase names (constants) that don't start with _
        if not name.isupper() or name.startswith("_"):
            continue

        # Check attribute exists before accessing
        if not hasattr(mt5, name):
            continue

        value = getattr(mt5, name)

        # Only include integer constants
        if isinstance(value, int):
            constants[name] = value

    conn.close()
    return constants


def group_constants(constants: dict[str, int]) -> dict[str, dict[str, int]]:
    """Group constants by prefix into enum classes."""
    groups: dict[str, dict[str, int]] = defaultdict(dict)

    for name, value in sorted(constants.items()):
        matched = False
        for prefix, class_name in PREFIX_TO_CLASS.items():
            if name.startswith(prefix):
                # Remove prefix to get enum member name
                member_name = name[len(prefix) :]
                groups[class_name][member_name] = value
                matched = True
                break

        if not matched:
            # Put unmatched constants in a generic group
            groups["_Misc"][name] = value

    return dict(groups)


def generate_enum_code(
    groups: dict[str, dict[str, int]],
    source: str,
) -> str:
    """Generate Python code for enum classes."""
    lines = [
        '"""MT5 enums auto-generated from MetaTrader5 library.',
        "",
        "DO NOT EDIT THIS FILE MANUALLY!",
        f"Source: {source}",
        "",
        "To regenerate:",
        "    python scripts/codegen_enums.py --output mt5linux/constants.py",
        '"""',
        "",
        "from enum import IntEnum",
        "",
        "__all__ = [",
    ]

    # Add all class names to __all__
    lines.extend(
        f'    "{class_name}",'
        for class_name in sorted(groups.keys())
        if not class_name.startswith("_")
    )
    lines.extend(("]", ""))

    # Generate enum classes
    for class_name in sorted(groups.keys()):
        if class_name.startswith("_"):
            continue

        members = groups[class_name]
        lines.extend(
            (
                "",
                f"class {class_name}(IntEnum):",
                f'    """MT5 {class_name} constants."""',
                "",
            )
        )

        for member_name, value in sorted(members.items(), key=operator.itemgetter(1)):
            # Ensure valid Python identifier
            safe_name = re.sub(r"[^A-Za-z0-9_]", "_", member_name)
            if safe_name[0].isdigit():
                safe_name = "_" + safe_name
            lines.append(f"    {safe_name} = {value}")

        lines.append("")

    return "\n".join(lines)


def validate_generated_code(code: str) -> bool:
    """Validate generated code is valid Python."""
    try:
        ast.parse(code)
        return True
    except SyntaxError as e:
        print(f"Generated code has syntax error: {e}", file=sys.stderr)
        return False


def _find_git_executable() -> str | None:
    """Find git executable cross-platform (Linux, macOS, Windows)."""
    # Try standard git first
    git_path = shutil.which("git")
    if git_path:
        return git_path

    # On Windows, also try git.exe explicitly
    if sys.platform == "win32":
        git_path = shutil.which("git.exe")
        if git_path:
            return git_path

    return None


def _is_git_repository(path: Path) -> bool:
    """Check if path is inside a git repository."""
    git_path = _find_git_executable()
    if not git_path:
        return False

    # Use git rev-parse to check if we're in a git repo
    result = subprocess.run(
        [git_path, "rev-parse", "--git-dir"],
        capture_output=True,
        cwd=path if path.is_dir() else path.parent,
        check=False,
    )
    return result.returncode == 0


def check_git_status(file_path: Path) -> bool:
    """Check if file has uncommitted changes in git.

    Returns:
        True if file is clean (no uncommitted changes) or not in a git repo
        False if file has uncommitted changes
    """
    git_path = _find_git_executable()
    if not git_path:
        # Git not available - skip check (not an error)
        print("Note: git not found, skipping commit check", file=sys.stderr)
        return True

    # Check if we're in a git repository
    if not _is_git_repository(file_path.parent):
        # Not a git repo - skip check (not an error)
        print("Note: not a git repository, skipping commit check", file=sys.stderr)
        return True

    # Check for unstaged changes
    result = subprocess.run(
        [git_path, "diff", "--quiet", str(file_path)],
        capture_output=True,
        cwd=file_path.parent,
        check=False,
    )
    if result.returncode != 0:
        print(f"ERROR: {file_path} has uncommitted changes!", file=sys.stderr)
        print("Run 'git add' and commit the updated constants.py", file=sys.stderr)
        return False

    # Check for staged but uncommitted changes
    result = subprocess.run(
        [git_path, "diff", "--cached", "--quiet", str(file_path)],
        capture_output=True,
        cwd=file_path.parent,
        check=False,
    )
    if result.returncode != 0:
        print(
            f"ERROR: {file_path} has staged but uncommitted changes!",
            file=sys.stderr,
        )
        print("Commit the updated constants.py", file=sys.stderr)
        return False

    return True


def generate_enums(  # noqa: PLR0911 - Complex codegen needs multiple return paths
    output_path: Path | None = None,
    check_only: bool = False,
    host: str = "localhost",
    port: int = Defaults.PORT_DOCKER_MAPPED,
) -> bool:
    """Generate constants.py from MT5 constants.

    REQUIRES Docker test container running on PORT_DOCKER_MAPPED (38812).
    No fallback - fails if Docker not available.

    Args:
        output_path: Output file path (default: mt5linux/constants.py)
        check_only: Only check if file needs commit (don't regenerate)
        host: rpyc server host
        port: rpyc server port (default: Defaults.PORT_DOCKER_MAPPED)

    Returns:
        True if generation successful (or check passed)
    """
    if output_path is None:
        output_path = Path(__file__).parent.parent / "mt5linux" / "constants.py"

    # Check Docker is available - NO FALLBACK
    if not is_rpyc_available(host, port):
        print(
            f"ERROR: Docker test container not running on port {port}!",
            file=sys.stderr,
        )
        print(
            "Start: docker compose -f tests/fixtures/docker-compose.yaml up -d",
            file=sys.stderr,
        )
        return False

    # Extract constants from Docker
    print(f"Extracting constants from Docker test container (rpyc:{port})...")
    try:
        constants = extract_from_rpyc(host, port)
        source = f"mt5docker test container (rpyc:{port})"
        print(f"  Extracted {len(constants)} constants")
    except (ConnectionError, ImportError, RuntimeError) as e:
        print(f"ERROR: Failed to extract constants: {e}", file=sys.stderr)
        return False
    except Exception as e:  # noqa: BLE001 - Catch-all for unexpected errors in enum extraction
        print(f"ERROR: Unexpected error extracting constants: {e}", file=sys.stderr)
        return False

    if not constants:
        print("ERROR: No constants extracted from MT5", file=sys.stderr)
        return False

    # Group and generate
    groups = group_constants(constants)
    print(f"Grouped into {len(groups)} enum classes")

    code = generate_enum_code(groups, source)

    if not validate_generated_code(code):
        return False

    # Write output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(code)
    print(f"Generated: {output_path}")

    # If check_only, verify git status after generation
    if check_only:
        return check_git_status(output_path)

    return True


def main() -> int:
    """CLI entry point."""

    parser = argparse.ArgumentParser(description="Generate MT5 enums")
    parser.add_argument(
        "--output",
        type=Path,
        help="Output file path",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if file needs commit (for CI/pytest)",
    )
    parser.add_argument(
        "--host",
        default=os.getenv("MT5_HOST", "localhost"),
        help="rpyc server host (default: localhost or MT5_HOST env)",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=int(os.getenv("MT5_RPYC_PORT", str(Defaults.PORT_DOCKER_MAPPED))),
        help=(
            f"rpyc server port "
            f"(default: {Defaults.PORT_DOCKER_MAPPED} or MT5_RPYC_PORT env)"
        ),
    )
    args = parser.parse_args()

    success = generate_enums(
        output_path=args.output,
        check_only=args.check,
        host=args.host,
        port=args.port,
    )
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
