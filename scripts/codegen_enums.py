#!/usr/bin/env python3
# ruff: noqa: T201, C901, FBT001, FBT002, TRY300, N813
"""Auto-generate MT5 enums from the real MetaTrader5 library.

This script extracts all constants from the MT5 library and generates
Python IntEnum classes for type-safe usage in neptor and mt5linux.

Sources (in priority order):
1. Docker mt5docker via rpyc (port 8001)
2. Local MetaTrader5 library (if installed)
3. Fallback: cached values from last successful generation

Usage:
    python scripts/codegen_enums.py [--output PATH] [--force]

Options:
    --output PATH   Output file path (default: mt5linux/enums.py)
    --force         Regenerate even if file exists and is recent
"""

from __future__ import annotations

import ast
import operator
import re
import socket
import sys
from collections import defaultdict
from datetime import UTC, datetime
from pathlib import Path

# Constants
CACHE_DURATION_SECONDS = 3600  # 1 hour

# Mapping of MT5 constant prefixes to enum class names
PREFIX_TO_CLASS: dict[str, str] = {
    "TIMEFRAME_": "TimeFrame",
    "ORDER_TYPE_": "OrderType",
    "TRADE_ACTION_": "TradeAction",
    "ORDER_STATE_": "OrderState",
    "ORDER_FILLING_": "OrderFilling",
    "ORDER_TIME_": "OrderTime",
    "ORDER_REASON_": "OrderReason",
    "DEAL_TYPE_": "DealType",
    "DEAL_ENTRY_": "DealEntry",
    "DEAL_REASON_": "DealReason",
    "POSITION_TYPE_": "PositionType",
    "POSITION_REASON_": "PositionReason",
    "ACCOUNT_TRADE_MODE_": "AccountTradeMode",
    "ACCOUNT_STOPOUT_MODE_": "AccountStopoutMode",
    "ACCOUNT_MARGIN_MODE_": "AccountMarginMode",
    "SYMBOL_CALC_MODE_": "SymbolCalcMode",
    "SYMBOL_CHART_MODE_": "SymbolChartMode",
    "SYMBOL_OPTION_MODE_": "SymbolOptionMode",
    "SYMBOL_OPTION_RIGHT_": "SymbolOptionRight",
    "SYMBOL_ORDERS_MODE_": "SymbolOrdersMode",
    "SYMBOL_SWAP_MODE_": "SymbolSwapMode",
    "SYMBOL_TRADE_EXECUTION_": "SymbolTradeExecution",
    "SYMBOL_TRADE_MODE_": "SymbolTradeMode",
    "BOOK_TYPE_": "BookType",
    "TRADE_RETCODE_": "TradeRetcode",
    "COPY_TICKS_": "CopyTicksFlag",
    "TICK_FLAG_": "TickFlag",
    "DAY_OF_WEEK_": "DayOfWeek",
}


def is_rpyc_available(host: str = "localhost", port: int = 8001) -> bool:
    """Check if rpyc server is available."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except (OSError, TimeoutError):
        return False


def extract_from_rpyc(host: str = "localhost", port: int = 8001) -> dict[str, int]:
    """Extract constants from MT5 via rpyc connection."""
    import rpyc

    conn = rpyc.classic.connect(host, port)
    mt5 = conn.modules.MetaTrader5

    constants: dict[str, int] = {}
    for name in dir(mt5):
        if name.isupper() and not name.startswith("_"):
            try:
                value = getattr(mt5, name)
                if isinstance(value, int):
                    constants[name] = value
            except Exception:  # noqa: BLE001, S110
                pass  # Intentionally ignore attribute errors

    conn.close()
    return constants


def extract_from_local() -> dict[str, int]:
    """Extract constants from locally installed MetaTrader5 library."""
    try:
        import MetaTrader5 as mt5_lib  # type: ignore[import-not-found]
    except ImportError:
        return {}

    constants: dict[str, int] = {}
    for name in dir(mt5_lib):
        if name.isupper() and not name.startswith("_"):
            try:
                value = getattr(mt5_lib, name)
                if isinstance(value, int):
                    constants[name] = value
            except Exception:  # noqa: BLE001, S110
                pass  # Intentionally ignore attribute errors

    return constants


def group_constants(constants: dict[str, int]) -> dict[str, dict[str, int]]:
    """Group constants by prefix into enum classes."""
    groups: dict[str, dict[str, int]] = defaultdict(dict)

    for name, value in sorted(constants.items()):
        matched = False
        for prefix, class_name in PREFIX_TO_CLASS.items():
            if name.startswith(prefix):
                # Remove prefix to get enum member name
                member_name = name[len(prefix) :]
                groups[class_name][member_name] = value
                matched = True
                break

        if not matched:
            # Put unmatched constants in a generic group
            groups["_Misc"][name] = value

    return dict(groups)


def generate_enum_code(
    groups: dict[str, dict[str, int]],
    source: str,
) -> str:
    """Generate Python code for enum classes."""
    timestamp = datetime.now(UTC).isoformat()

    lines = [
        '"""MT5 enums auto-generated from MetaTrader5 library.',
        "",
        "DO NOT EDIT THIS FILE MANUALLY!",
        f"Generated: {timestamp}",
        f"Source: {source}",
        "",
        "To regenerate:",
        "    python scripts/codegen_enums.py",
        '"""',
        "",
        "from enum import IntEnum",
        "",
        "__all__ = [",
    ]

    # Add all class names to __all__
    lines.extend(
        f'    "{class_name}",'
        for class_name in sorted(groups.keys())
        if not class_name.startswith("_")
    )
    lines.extend(("]", ""))

    # Generate enum classes
    for class_name in sorted(groups.keys()):
        if class_name.startswith("_"):
            continue

        members = groups[class_name]
        lines.extend(
            (
                "",
                f"class {class_name}(IntEnum):",
                f'    """MT5 {class_name} constants."""',
                "",
            )
        )

        for member_name, value in sorted(members.items(), key=operator.itemgetter(1)):
            # Ensure valid Python identifier
            safe_name = re.sub(r"[^A-Za-z0-9_]", "_", member_name)
            if safe_name[0].isdigit():
                safe_name = "_" + safe_name
            lines.append(f"    {safe_name} = {value}")

        lines.append("")

    return "\n".join(lines)


def validate_generated_code(code: str) -> bool:
    """Validate generated code is valid Python."""
    try:
        ast.parse(code)
        return True
    except SyntaxError as e:
        print(f"Generated code has syntax error: {e}", file=sys.stderr)
        return False


def generate_enums(
    output_path: Path | None = None,
    force: bool = False,
) -> bool:
    """Generate enums.py from MT5 constants.

    Args:
        output_path: Output file path (default: mt5linux/enums.py)
        force: Regenerate even if file exists

    Returns:
        True if generation successful
    """
    if output_path is None:
        output_path = Path(__file__).parent.parent / "mt5linux" / "enums.py"

    # Check if regeneration needed
    if output_path.exists() and not force:
        # Skip if file was modified recently (within 1 hour)
        mtime = datetime.fromtimestamp(output_path.stat().st_mtime, tz=UTC)
        age = datetime.now(UTC) - mtime
        if age.total_seconds() < CACHE_DURATION_SECONDS:
            print(f"Skipping: {output_path} is recent (modified {age} ago)")
            return True

    # Try to extract constants
    constants: dict[str, int] = {}
    source = "unknown"

    # Priority 1: Docker rpyc
    if is_rpyc_available():
        print("Extracting constants from Docker mt5docker (rpyc:8001)...")
        try:
            constants = extract_from_rpyc()
            source = "mt5docker (rpyc:8001)"
            print(f"  Extracted {len(constants)} constants")
        except Exception as e:  # noqa: BLE001
            print(f"  Failed: {e}")

    # Priority 2: Local MetaTrader5
    if not constants:
        print("Extracting constants from local MetaTrader5...")
        constants = extract_from_local()
        if constants:
            source = "local MetaTrader5"
            print(f"  Extracted {len(constants)} constants")
        else:
            print("  MetaTrader5 not installed")

    # Priority 3: Fallback - read existing file
    if not constants and output_path.exists():
        print(f"Using existing {output_path} as fallback")
        return True

    if not constants:
        print("ERROR: No MT5 constants available", file=sys.stderr)
        return False

    # Group and generate
    groups = group_constants(constants)
    print(f"Grouped into {len(groups)} enum classes")

    code = generate_enum_code(groups, source)

    if not validate_generated_code(code):
        return False

    # Write output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(code)
    print(f"Generated: {output_path}")

    return True


def main() -> int:
    """CLI entry point."""
    import argparse

    parser = argparse.ArgumentParser(description="Generate MT5 enums")
    parser.add_argument(
        "--output",
        type=Path,
        help="Output file path",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force regeneration",
    )
    args = parser.parse_args()

    success = generate_enums(output_path=args.output, force=args.force)
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
