#!/usr/bin/env python3
# ruff: noqa: T201, C901, TRY300, N813
"""Auto-generate MT5 enums from the real MetaTrader5 library.

This script extracts all constants from the MT5 library and generates
Python IntEnum classes for type-safe usage in neptor and mt5linux.

REQUIRES: Docker test container running on port 38812
  (tests/fixtures/docker-compose.test.yaml)

NO FALLBACK - fails if Docker not available.

Usage:
    python scripts/codegen_enums.py [--output PATH] [--check]

Options:
    --output PATH   Output file path (default: mt5linux/enums.py)
    --check         Check if file needs commit (for CI/pytest)

This script is run automatically before pytest via conftest.py.
If --check fails, commit the updated enums.py to the repository.
"""

from __future__ import annotations

import ast
import operator
import re
import socket
import subprocess
import sys
from collections import defaultdict
from pathlib import Path

# Mapping of MT5 constant prefixes to enum class names
PREFIX_TO_CLASS: dict[str, str] = {
    "TIMEFRAME_": "TimeFrame",
    "ORDER_TYPE_": "OrderType",
    "TRADE_ACTION_": "TradeAction",
    "ORDER_STATE_": "OrderState",
    "ORDER_FILLING_": "OrderFilling",
    "ORDER_TIME_": "OrderTime",
    "ORDER_REASON_": "OrderReason",
    "DEAL_TYPE_": "DealType",
    "DEAL_ENTRY_": "DealEntry",
    "DEAL_REASON_": "DealReason",
    "POSITION_TYPE_": "PositionType",
    "POSITION_REASON_": "PositionReason",
    "ACCOUNT_TRADE_MODE_": "AccountTradeMode",
    "ACCOUNT_STOPOUT_MODE_": "AccountStopoutMode",
    "ACCOUNT_MARGIN_MODE_": "AccountMarginMode",
    "SYMBOL_CALC_MODE_": "SymbolCalcMode",
    "SYMBOL_CHART_MODE_": "SymbolChartMode",
    "SYMBOL_OPTION_MODE_": "SymbolOptionMode",
    "SYMBOL_OPTION_RIGHT_": "SymbolOptionRight",
    "SYMBOL_ORDERS_MODE_": "SymbolOrdersMode",
    "SYMBOL_SWAP_MODE_": "SymbolSwapMode",
    "SYMBOL_TRADE_EXECUTION_": "SymbolTradeExecution",
    "SYMBOL_TRADE_MODE_": "SymbolTradeMode",
    "BOOK_TYPE_": "BookType",
    "TRADE_RETCODE_": "TradeRetcode",
    "COPY_TICKS_": "CopyTicksFlag",
    "TICK_FLAG_": "TickFlag",
    "DAY_OF_WEEK_": "DayOfWeek",
}


def is_rpyc_available(host: str = "localhost", port: int = 38812) -> bool:
    """Check if rpyc server is available on test container port."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except (OSError, TimeoutError):
        return False


def extract_from_rpyc(host: str = "localhost", port: int = 38812) -> dict[str, int]:
    """Extract constants from MT5 via rpyc 6.x native API."""
    import rpyc

    # rpyc 6.x native API - connect to SlaveService
    conn = rpyc.connect(host, port, service=rpyc.SlaveService)
    mt5 = conn.root.getmodule("MetaTrader5")

    constants: dict[str, int] = {}
    for name in dir(mt5):
        if name.isupper() and not name.startswith("_"):
            try:
                value = getattr(mt5, name)
                if isinstance(value, int):
                    constants[name] = value
            except Exception:  # noqa: BLE001, S110
                pass  # Intentionally ignore attribute errors

    conn.close()
    return constants




def group_constants(constants: dict[str, int]) -> dict[str, dict[str, int]]:
    """Group constants by prefix into enum classes."""
    groups: dict[str, dict[str, int]] = defaultdict(dict)

    for name, value in sorted(constants.items()):
        matched = False
        for prefix, class_name in PREFIX_TO_CLASS.items():
            if name.startswith(prefix):
                # Remove prefix to get enum member name
                member_name = name[len(prefix) :]
                groups[class_name][member_name] = value
                matched = True
                break

        if not matched:
            # Put unmatched constants in a generic group
            groups["_Misc"][name] = value

    return dict(groups)


def generate_enum_code(
    groups: dict[str, dict[str, int]],
    source: str,
) -> str:
    """Generate Python code for enum classes."""
    lines = [
        '"""MT5 enums auto-generated from MetaTrader5 library.',
        "",
        "DO NOT EDIT THIS FILE MANUALLY!",
        f"Source: {source}",
        "",
        "To regenerate:",
        "    python scripts/codegen_enums.py",
        '"""',
        "",
        "from enum import IntEnum",
        "",
        "__all__ = [",
    ]

    # Add all class names to __all__
    lines.extend(
        f'    "{class_name}",'
        for class_name in sorted(groups.keys())
        if not class_name.startswith("_")
    )
    lines.extend(("]", ""))

    # Generate enum classes
    for class_name in sorted(groups.keys()):
        if class_name.startswith("_"):
            continue

        members = groups[class_name]
        lines.extend(
            (
                "",
                f"class {class_name}(IntEnum):",
                f'    """MT5 {class_name} constants."""',
                "",
            )
        )

        for member_name, value in sorted(members.items(), key=operator.itemgetter(1)):
            # Ensure valid Python identifier
            safe_name = re.sub(r"[^A-Za-z0-9_]", "_", member_name)
            if safe_name[0].isdigit():
                safe_name = "_" + safe_name
            lines.append(f"    {safe_name} = {value}")

        lines.append("")

    return "\n".join(lines)


def validate_generated_code(code: str) -> bool:
    """Validate generated code is valid Python."""
    try:
        ast.parse(code)
        return True
    except SyntaxError as e:
        print(f"Generated code has syntax error: {e}", file=sys.stderr)
        return False


def check_git_status(file_path: Path) -> bool:
    """Check if file has uncommitted changes in git.

    Returns:
        True if file is clean (no uncommitted changes)
        False if file has uncommitted changes
    """
    try:
        result = subprocess.run(
            ["git", "diff", "--quiet", str(file_path)],  # noqa: S607
            capture_output=True,
            cwd=file_path.parent,
            check=False,
        )
        if result.returncode != 0:
            print(f"ERROR: {file_path} has uncommitted changes!", file=sys.stderr)
            print("Run 'git add' and commit the updated enums.py", file=sys.stderr)
            return False

        # Also check staged changes
        result = subprocess.run(
            ["git", "diff", "--cached", "--quiet", str(file_path)],  # noqa: S607
            capture_output=True,
            cwd=file_path.parent,
            check=False,
        )
        if result.returncode != 0:
            print(
                f"ERROR: {file_path} has staged but uncommitted changes!",
                file=sys.stderr,
            )
            print("Commit the updated enums.py", file=sys.stderr)
            return False

        return True
    except FileNotFoundError:
        # git not available, skip check
        return True


def generate_enums(
    output_path: Path | None = None,
    check_only: bool = False,
    host: str = "localhost",
    port: int = 38812,
) -> bool:
    """Generate enums.py from MT5 constants.

    REQUIRES Docker test container running on port 38812.
    No fallback - fails if Docker not available.

    Args:
        output_path: Output file path (default: mt5linux/enums.py)
        check_only: Only check if file needs commit (don't regenerate)
        host: rpyc server host
        port: rpyc server port (default: 38812 for test container)

    Returns:
        True if generation successful (or check passed)
    """
    if output_path is None:
        output_path = Path(__file__).parent.parent / "mt5linux" / "enums.py"

    # Check Docker is available - NO FALLBACK
    if not is_rpyc_available(host, port):
        print(
            f"ERROR: Docker test container not running on port {port}!",
            file=sys.stderr,
        )
        print(
            "Start: docker compose -f tests/fixtures/docker-compose.test.yaml up -d",
            file=sys.stderr,
        )
        return False

    # Extract constants from Docker
    print(f"Extracting constants from Docker test container (rpyc:{port})...")
    try:
        constants = extract_from_rpyc(host, port)
        source = f"mt5docker test container (rpyc:{port})"
        print(f"  Extracted {len(constants)} constants")
    except Exception as e:  # noqa: BLE001
        print(f"ERROR: Failed to extract constants: {e}", file=sys.stderr)
        return False

    if not constants:
        print("ERROR: No constants extracted from MT5", file=sys.stderr)
        return False

    # Group and generate
    groups = group_constants(constants)
    print(f"Grouped into {len(groups)} enum classes")

    code = generate_enum_code(groups, source)

    if not validate_generated_code(code):
        return False

    # Write output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(code)
    print(f"Generated: {output_path}")

    # If check_only, verify git status after generation
    if check_only:
        return check_git_status(output_path)

    return True


def main() -> int:
    """CLI entry point."""
    import argparse
    import os

    parser = argparse.ArgumentParser(description="Generate MT5 enums")
    parser.add_argument(
        "--output",
        type=Path,
        help="Output file path",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if file needs commit (for CI/pytest)",
    )
    parser.add_argument(
        "--host",
        default=os.getenv("MT5_HOST", "localhost"),
        help="rpyc server host (default: localhost or MT5_HOST env)",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=int(os.getenv("MT5_RPYC_PORT", "38812")),
        help="rpyc server port (default: 38812 or MT5_RPYC_PORT env)",
    )
    args = parser.parse_args()

    success = generate_enums(
        output_path=args.output,
        check_only=args.check,
        host=args.host,
        port=args.port,
    )
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
