"""RPyC server for mt5linux.

Production-grade RPyC server with:
- Automatic restart on failure with exponential backoff
- Structured logging via structlog
- Graceful shutdown handling
- Health check support
- Wine subprocess management

Compatible with rpyc 6.x.

Usage:
    # Direct mode (Linux with rpyc):
    python -m mt5linux.server --host 0.0.0.0 --port 18812

    # Wine mode (for mt5docker):
    python -m mt5linux.server --wine wine --python python.exe -p 8001
"""

from __future__ import annotations

import argparse
import signal
import subprocess
import sys
import threading
from collections.abc import Iterator
from contextlib import contextmanager
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from types import FrameType

import rpyc
import structlog

# rpyc 6.x: SlaveService is aliased to ClassicService, both work
from rpyc.core import SlaveService
from rpyc.utils.server import ThreadedServer

# Configure structlog for clean output
structlog.configure(
    processors=[
        structlog.stdlib.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.dev.ConsoleRenderer(colors=True),
    ],
    wrapper_class=structlog.make_filtering_bound_logger(0),
    context_class=dict,
    logger_factory=structlog.PrintLoggerFactory(),
    cache_logger_on_first_use=True,
)

log = structlog.get_logger("mt5linux.server")


class ServerMode(Enum):
    """Server execution mode."""

    DIRECT = "direct"  # Run RPyC server directly (Linux)
    WINE = "wine"  # Run via Wine subprocess (Windows Python)


class ServerState(Enum):
    """Server lifecycle state."""

    STOPPED = "stopped"
    STARTING = "starting"
    RUNNING = "running"
    RESTARTING = "restarting"
    STOPPING = "stopping"
    FAILED = "failed"


@dataclass
class ServerConfig:
    """Server configuration with sensible defaults."""

    host: str = "0.0.0.0"
    port: int = 18812
    mode: ServerMode = ServerMode.DIRECT

    # Wine mode settings
    wine_cmd: str = "wine"
    python_exe: str = "python.exe"
    server_dir: Path = field(default_factory=lambda: Path("/tmp/mt5linux"))

    # Resilience settings
    max_restarts: int = 10
    restart_delay_base: float = 1.0  # Base delay in seconds
    restart_delay_max: float = 60.0  # Maximum delay
    restart_delay_multiplier: float = 2.0  # Exponential backoff multiplier

    # Health check settings
    health_check_interval: float = 30.0  # Seconds between checks
    health_check_timeout: float = 5.0  # Timeout for health check

    def __post_init__(self) -> None:
        """Ensure server_dir is a Path."""
        if isinstance(self.server_dir, str):
            self.server_dir = Path(self.server_dir)


# RPyC server script template for Wine mode
# Uses SlaveService which is aliased to ClassicService in rpyc 6.x
RPYC_SERVER_SCRIPT = '''\
#!/usr/bin/env python
"""RPyC server with graceful shutdown support.

Generated by mt5linux.server.
Runs inside Wine with Windows Python + MetaTrader5 module.
Compatible with rpyc 6.x.
Features:
- Signal handling (SIGTERM/SIGINT) for clean shutdown
- Clean shutdown of ThreadedServer
"""
import sys
import signal
from rpyc.utils.server import ThreadedServer
from rpyc.core import SlaveService  # SlaveService = ClassicService in rpyc 6.x

# Global server reference for signal handler
_server = None

def graceful_shutdown(signum, frame):
    """Handle shutdown signals for clean process stops."""
    sig_name = "SIGTERM" if signum == signal.SIGTERM else "SIGINT"
    print(f"[mt5linux] Received {sig_name}, shutting down gracefully...")
    if _server is not None:
        _server.close()
    sys.exit(0)

if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else "0.0.0.0"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 18812

    # Setup signal handlers
    signal.signal(signal.SIGTERM, graceful_shutdown)
    signal.signal(signal.SIGINT, graceful_shutdown)

    print(f"[mt5linux] Starting RPyC server on {host}:{port}")

    _server = ThreadedServer(
        SlaveService,
        hostname=host,
        port=port,
        reuse_addr=True,
    )

    try:
        _server.start()
    except KeyboardInterrupt:
        print("[mt5linux] Server interrupted")
    except Exception as e:
        print(f"[mt5linux] Server error: {e}")
        sys.exit(1)
    finally:
        if _server is not None:
            _server.close()
        print("[mt5linux] Server stopped")
'''


class Server:
    """Production-grade RPyC server with automatic recovery.

    Features:
    - Automatic restart on failure with exponential backoff
    - Graceful shutdown on SIGTERM/SIGINT
    - Health monitoring (optional)
    - Structured logging

    Example:
        >>> config = ServerConfig(host="0.0.0.0", port=8001, mode=ServerMode.WINE)
        >>> server = Server(config)
        >>> server.run()  # Blocks until shutdown
    """

    def __init__(self, config: ServerConfig | None = None) -> None:
        """Initialize server with configuration.

        Args:
            config: Server configuration. Uses defaults if None.
        """
        self.config = config or ServerConfig()
        self._state = ServerState.STOPPED
        self._restart_count = 0
        self._shutdown_event = threading.Event()
        self._process: subprocess.Popen[str] | None = None
        self._server_thread: threading.Thread | None = None
        self._log = log.bind(
            host=self.config.host,
            port=self.config.port,
            mode=self.config.mode.value,
        )

    @property
    def state(self) -> ServerState:
        """Current server state."""
        return self._state

    @property
    def restart_count(self) -> int:
        """Number of restarts since last successful run."""
        return self._restart_count

    def _set_state(self, state: ServerState) -> None:
        """Update server state with logging."""
        old_state = self._state
        self._state = state
        self._log.debug(
            "state_changed", old_state=old_state.value, new_state=state.value
        )

    def _calculate_restart_delay(self) -> float:
        """Calculate delay before next restart using exponential backoff."""
        delay = self.config.restart_delay_base * (
            self.config.restart_delay_multiplier ** self._restart_count
        )
        return min(delay, self.config.restart_delay_max)

    def _setup_signal_handlers(self) -> None:
        """Setup graceful shutdown signal handlers."""

        def signal_handler(signum: int, _frame: FrameType | None) -> None:
            sig_name = signal.Signals(signum).name
            self._log.info("signal_received", signal=sig_name)
            self.stop()

        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)

    def _generate_server_script(self) -> Path:
        """Generate RPyC server script for Wine mode.

        Returns:
            Path to generated script.
        """
        self.config.server_dir.mkdir(parents=True, exist_ok=True)
        script_path = self.config.server_dir / "rpyc_server.py"
        script_path.write_text(RPYC_SERVER_SCRIPT)
        self._log.debug("script_generated", path=str(script_path))
        return script_path

    def _run_wine_server(self) -> int:
        """Run RPyC server via Wine subprocess.

        Returns:
            Exit code from Wine process.
        """
        script_path = self._generate_server_script()

        cmd = [
            self.config.wine_cmd,
            self.config.python_exe,
            str(script_path),
            self.config.host,
            str(self.config.port),
        ]

        self._log.info("starting_wine_server", command=" ".join(cmd))

        self._process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,  # Line buffered
        )

        # Stream output in real-time
        if self._process.stdout:
            for raw_line in self._process.stdout:
                output = raw_line.rstrip()
                if output:
                    # Parse log level from Wine output
                    if "error" in output.lower():
                        self._log.error("wine_output", message=output)
                    elif "warning" in output.lower():
                        self._log.warning("wine_output", message=output)
                    else:
                        self._log.info("wine_output", message=output)

                # Check for shutdown
                if self._shutdown_event.is_set():
                    break

        return self._process.wait()

    def _run_direct_server(self) -> int:
        """Run RPyC server directly (Linux mode).

        Returns:
            Exit code (0 for normal shutdown).
        """

        self._log.info("starting_direct_server")

        server = ThreadedServer(
            SlaveService,
            hostname=self.config.host,
            port=self.config.port,
            reuse_addr=True,
        )

        try:
            server.start()
        except KeyboardInterrupt:
            self._log.info("server_interrupted")
        finally:
            server.close()

        return 0

    def _server_loop(self) -> None:
        """Main server loop with restart logic."""
        self._set_state(ServerState.RUNNING)

        while not self._shutdown_event.is_set():
            self._set_state(ServerState.STARTING)

            try:
                if self.config.mode == ServerMode.WINE:
                    exit_code = self._run_wine_server()
                else:
                    exit_code = self._run_direct_server()

                if self._shutdown_event.is_set():
                    self._log.info("server_shutdown_requested")
                    break

                if exit_code == 0:
                    self._log.info("server_exited_normally", exit_code=exit_code)
                    self._restart_count = 0  # Reset on clean exit
                    break

                # Non-zero exit - attempt restart
                self._restart_count += 1
                if self._restart_count > self.config.max_restarts:
                    self._log.error(
                        "max_restarts_exceeded",
                        max_restarts=self.config.max_restarts,
                    )
                    self._set_state(ServerState.FAILED)
                    break

                delay = self._calculate_restart_delay()
                self._log.warning(
                    "server_crashed",
                    exit_code=exit_code,
                    restart_count=self._restart_count,
                    restart_delay=delay,
                )

                self._set_state(ServerState.RESTARTING)

                # Wait with shutdown check
                if self._shutdown_event.wait(delay):
                    break  # Shutdown requested during wait

            except Exception:
                self._log.exception("server_error")
                self._restart_count += 1

                if self._restart_count > self.config.max_restarts:
                    self._set_state(ServerState.FAILED)
                    break

                delay = self._calculate_restart_delay()
                self._set_state(ServerState.RESTARTING)

                if self._shutdown_event.wait(delay):
                    break

        self._set_state(ServerState.STOPPED)

    def run(self, *, blocking: bool = True) -> None:
        """Start the server.

        Args:
            blocking: If True, blocks until server stops. If False, runs in background.
        """
        self._shutdown_event.clear()
        self._setup_signal_handlers()

        self._log.info(
            "server_starting",
            blocking=blocking,
            max_restarts=self.config.max_restarts,
        )

        if blocking:
            self._server_loop()
        else:
            self._server_thread = threading.Thread(
                target=self._server_loop,
                name="mt5linux-server",
                daemon=True,
            )
            self._server_thread.start()

    def stop(self, timeout: float = 10.0) -> None:
        """Stop the server gracefully.

        Args:
            timeout: Maximum time to wait for shutdown.
        """
        self._log.info("stopping_server")
        self._set_state(ServerState.STOPPING)
        self._shutdown_event.set()

        # Terminate Wine process if running
        if self._process and self._process.poll() is None:
            self._log.debug("terminating_wine_process")
            self._process.terminate()
            try:
                self._process.wait(timeout=timeout)
            except subprocess.TimeoutExpired:
                self._log.warning("killing_wine_process")
                self._process.kill()

        # Wait for server thread
        if self._server_thread and self._server_thread.is_alive():
            self._server_thread.join(timeout=timeout)

        self._set_state(ServerState.STOPPED)
        self._log.info("server_stopped")

    def check_health(self) -> bool:
        """Check if server is healthy by attempting RPyC connection.

        Returns:
            True if server responds to health check.
        """
        try:

            host = self.config.host if self.config.host != "0.0.0.0" else "localhost"
            conn = rpyc.classic.connect(host, self.config.port)
            conn.close()
        except Exception:
            return False
        else:
            return True

    @contextmanager
    def managed(self) -> Iterator[Server]:
        """Context manager for automatic start/stop.

        Example:
            >>> with Server(config).managed() as server:
            ...     # Server is running
            ...     pass
            # Server is stopped
        """
        self.run(blocking=False)
        try:
            yield self
        finally:
            self.stop()


def parse_args(argv: list[str] | None = None) -> ServerConfig:
    """Parse command line arguments into ServerConfig.

    Args:
        argv: Command line arguments. Uses sys.argv if None.

    Returns:
        Parsed configuration.
    """
    parser = argparse.ArgumentParser(
        description="Resilient RPyC server for MetaTrader5",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # Connection settings
    parser.add_argument(
        "--host",
        default="0.0.0.0",
        help="Host to bind to",
    )
    parser.add_argument(
        "-p", "--port",
        type=int,
        default=18812,
        help="Port to listen on",
    )

    # Mode selection
    parser.add_argument(
        "--wine", "-w",
        dest="wine_cmd",
        metavar="CMD",
        help="Wine command (enables Wine mode)",
    )
    parser.add_argument(
        "--python",
        dest="python_exe",
        default="python.exe",
        help="Python executable path (Wine mode)",
    )

    # Resilience settings
    parser.add_argument(
        "--max-restarts",
        type=int,
        default=10,
        help="Maximum restart attempts",
    )
    parser.add_argument(
        "--server-dir",
        default="/tmp/mt5linux",
        help="Directory for server script (Wine mode)",
    )

    args = parser.parse_args(argv)

    # Determine mode based on wine argument
    mode = ServerMode.WINE if args.wine_cmd else ServerMode.DIRECT

    return ServerConfig(
        host=args.host,
        port=args.port,
        mode=mode,
        wine_cmd=args.wine_cmd or "wine",
        python_exe=args.python_exe,
        server_dir=Path(args.server_dir),
        max_restarts=args.max_restarts,
    )


def run_server(
    host: str = "0.0.0.0",
    port: int = 18812,
    *,
    wine_cmd: str | None = None,
    python_exe: str = "python.exe",
    max_restarts: int = 10,
) -> None:
    """Run resilient RPyC server.

    Convenience function for programmatic use.

    Args:
        host: Host to bind to.
        port: Port to listen on.
        wine_cmd: Wine command (None for direct mode).
        python_exe: Python executable for Wine mode.
        max_restarts: Maximum restart attempts.
    """
    config = ServerConfig(
        host=host,
        port=port,
        mode=ServerMode.WINE if wine_cmd else ServerMode.DIRECT,
        wine_cmd=wine_cmd or "wine",
        python_exe=python_exe,
        max_restarts=max_restarts,
    )

    server = Server(config)
    server.run(blocking=True)


def main() -> int:
    """Entry point for command line usage.

    Returns:
        Exit code.
    """
    config = parse_args()
    server = Server(config)

    try:
        server.run(blocking=True)
    except KeyboardInterrupt:
        server.stop()
        return 0
    else:
        return 0 if server.state != ServerState.FAILED else 1


if __name__ == "__main__":
    sys.exit(main())
